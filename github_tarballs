#!/usr/bin/env python
#
# Copyright 2012 SUSE Linux
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import argparse
from datetime import datetime
import glob
import json
import os
import re
import sys
import tarfile
import urllib


COMMIT_HASH_SIZE = 7
GITHUB_BRANCHES = "https://api.github.com/repos/%(owner)s/%(repo)s/branches/%(target)s"
GITHUB_COMPARE = "https://api.github.com/repos/%(owner)s/%(repo)s/compare/%(base)s...%(head)s"
GITHUB_TAGS = "https://api.github.com/repos/%(owner)s/%(repo)s/git/refs/tags/"
GITHUB_TAG = "https://api.github.com/repos/%(owner)s/%(repo)s/git/tags/%(tag)s"
GITHUB_TAR = "https://github.com/%(owner)s/%(repo)s/archive/%(target)s.tar.gz"


def github(url, errors=True):
    """Connect to github's API and return a urllib response object"""
    try:
        res = urllib.urlopen(url)
    except IOError as e:
        if errors:
            sys.exit(e)
        return None
    return res
        

def download_tarball(owner, repo, target, filename):
    """Download an upstream tarball

    :owner: github repository owner (user or organization)
    :repo: github repository name
    :target: commit or git ref
    :filename: filename to save the tarball to

    """
    url = GITHUB_TAR % locals()
    try:
        urllib.urlretrieve(url, filename)
    except IOError as e:
        sys.exit(e)


def get_parent_dir_and_version_from_tarball(tar_name):
    try:
        tar = tarfile.open(tar_name)
        parent_dir = tar.firstmember.name
        version = parent_dir.rsplit('-', 1)[1]
        return (parent_dir, version)
    except IndexError:
        sys.exit("Could not figure out version from directory "
                 "inside tarball: " + tar.firstmember.name)
    finally:
        tar.close()


def get_commit_from_spec(package):
    """Parse the spec's Version field for a previously set commit version

    :package: name of the package

    Returns None in case no commit could be read.

    """
    try:
        f = open(package + '.spec')
        return re.search(r'^Version:\s+.*\+git\.\d+\.(.*?)(\s+#.*)?$',
                         f.read(), flags=re.MULTILINE).group(1)
    except AttributeError:
        return None
    finally:
        f.close()

def get_target_sha(owner, repo, target):
    url = GITHUB_BRANCHES % locals()
    tag = json.loads(github(url).read())
    return tag['commit']['sha']

def get_upstream_version(owner, repo, target):
    url = GITHUB_TAGS % locals()
    res = github(url)
    if res.code != 200:
        sys.exit("Could not read commits from %s. %s "
                 % (url, json.loads(res.read())['message']))

    tags = json.loads(res.read())
    tags.reverse()
    # we now have the list of tags in descending cronological order, but
    # we don't know what branch they're on. So we're going to compare
    # commits and look if the branches have diverged. We're looking for
    # the 'behind' status because that means that the branch comes
    # before the tag commit
    branch_sha = get_target_sha(owner, repo, target)
    
    for tag in tags:
        tag_url = tag['object']['url']
        tag = json.loads(github(tag_url).read())

        url = GITHUB_COMPARE % dict(base=branch_sha,
                                    head=tag['object']['sha'], **locals())
        res = github(url, errors=False)
        if not res:
            print 'ooooo: ', url
            # no path found from branch to tag, the tag must be on a
            # different branch
            continue

        # the result can be huge, but the status should be at the beginning
        while True:
            header = res.read(1024)
            if '"status"' in header:
                status = re.search(r'"status":"(\w+)"', header).groups()[0]
                break

        if status == 'behind':
            return tag['tag']

def package_version(git_compare, upstream_version):
    try:
        upstream_commit = git_compare['commits'][-1]
    except IndexError:
        upstream_commit = git_compare['base_commit']

    sha = upstream_commit['sha'][:COMMIT_HASH_SIZE]

    return '%s+git.%s.%s' % (upstream_version,
                             datetime.now().strftime('%s'),
                             sha)


def update_spec_file(package_version, tarball_parent_dir, filename):
    for specfile in glob.glob('./*.spec'):
        try:
            f = open(specfile, 'r+')
            contents = f.read()
            f.seek(0)
            f.truncate()
            contents = re.sub(r'\n((Version:\s+).*)\n',
                              r'\n\g<2>%s\n' % package_version,
                              contents, count=1)
            contents = re.sub(r'\n((%setup\s+).*)\n',
                              r'\n\g<2>-q -n %s\n' % tarball_parent_dir,
                              contents, count=1)
            contents = re.sub(r'\n((Source0?:\s+).*)\n',
                              r'\n\g<2>%s\n' % filename,
                              contents, count=1)
            f.write(contents)
        finally:
            f.close()


def create_changes(git_compare, package_version, email):
    """Return a string with the new changes for the .changes file

    :git_compare: JSON data from github commit compare
    :package_version: release version string for the .changes file entry
    :email: email address used for the .changes file entry

    """
    timestamp = datetime.utcnow().strftime('%a %b %e %T UTC %Y')

    if git_compare['commits']:
        commits = "  + " + "\n  + ".join(
            c['commit']['message'].split('\n')[0]
            for c in git_compare['commits']
            if not c['commit']['message'].startswith('Merge '))

        message = ('- Update to version %(package_version)s:\n'
                   '%(commits)s\n') % locals()
    else:
        message = '- Start using obs-service-github_tarballs\n'

    change = (
        '--------------------------------------------------------------------\n'
        '%(timestamp)s - %(email)s\n'
        '\n%(message)s\n' % locals())

    return change


def update_changes_file(package, changes):
    try:
        f = open(package + ".changes", "r+")
        contents = f.read()
        f.seek(0)
        f.write(changes)
        f.write(contents)
    finally:
        f.close()


def get_changes(package, owner, repo, target):
    """Return a dict of new commits from github compare

    See http://developer.github.com/v3/repos/commits/#compare-two-commits

    The dict contains:
    {
     "commits": [{
         "url": ...,
         "commit": {
             "message": ...,
             ...
         },
         ...
     }, ...]
    }

    """
    current_commit = get_commit_from_spec(package)
    url = GITHUB_COMPARE % dict(owner=owner,
                                repo=repo,
                                base=current_commit or target,
                                head=target)
    try:
        res = urllib.urlopen(url)
    except IOError as e:
        sys.exit(e)

    if res.code != 200:
        sys.exit("Could not read commits from %s. %s "
                 % (url, json.loads(res.read())['message']))

    data = json.loads(res.read())

    return data


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Git Tarballs')
    parser.add_argument('--url', required=True,
                        help='upstream tarball URL to download')
    parser.add_argument('--filename',
                        help='where to save the downloaded tarball')
    parser.add_argument('--package',
                        help='the OBS package name')
    parser.add_argument('--repo_owner',
                        help='github repository owner')
    parser.add_argument('--repo_name',
                        help='github repository name')
    parser.add_argument('--target',
                        help='git repository target commit/ref to update to')
    parser.add_argument('--email', required=True,
                        help="commit author's email (for the .changes file)")
    parser.add_argument('--outdir',
                        help='osc service parameter that does nothing')
    args = parser.parse_args()

    if not args.filename:
        args.filename = args.repo_name + ".tar.gz"
    if not args.package:
        args.package = os.getcwd().rsplit("/", 1)[1]

    download_tarball(args.repo_owner, args.repo_name, args.target)

    tarball_parent_dir, upstream_version = get_parent_dir_and_version_from_tarball(args.filename)

    git_compare = get_changes(args.package, args.repo_owner,
                              args.repo_name, args.target)
    current_version = package_version(git_compare, upstream_version)

    changes = create_changes(git_compare, current_version, args.email)
    update_changes_file(args.package, changes)
    update_spec_file(current_version, tarball_parent_dir, args.filename)
